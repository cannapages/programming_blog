<!DOCTYPE html><!-- From HTML5 Boilerplate -->
<html class="no-js" lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<title>Structurer une application Web avec Express et Node.js</title>
		<meta name="description" content="La façon d&#39;organiser son code, en divers répertoires et fichiers, est en bonne partie une question de préférence personnelle. Le cadre d&#39;application Web Express n&#39;impose aucune structure particulière, laissant le développeur totalement libre d&#39;arranger le tout selon son inspiration du moment. Cette liberté peut parfois donner le vertige et provoquer un effet pervers: le syndrome de la page blanche." />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="stylesheet" href="/css/normalize.css" />
		<link rel="stylesheet" href="/css/main.css" />
		<link rel="stylesheet" href="/css/fontello.css" />
		<link type="text/css" href="http://fonts.googleapis.com/css?family=Telex" rel="stylesheet" />
		<link title="RSS" href="http://localhost/rss" rel="alternate" type="application/rss&#43;xml" />
	</head>
	<body>
		
		<div class="header">
			<div class="title">
				<a href="/">Site Name</a>
				<br />
				<span class="tagline"></span>
			</div>
		</div>
		<nav>
			<div class="container">
				<div class="left">
					<a class="huge" href="006-dependency-injection" title="Expérimentations sur l&#39;injection de dépendance avec node.js">«</a>
				</div>
				<div class="middle">
					<span>Structurer une application Web avec Express et Node.js</span>
				</div>
				<div class="right">
					<a href="004-npm-packages" title="npm shrinkwrap: Comment contrôler ses dépendances" class="huge">»</a>
				</div>
				<div class="clearfix"></div>
			</div>
		</nav>
		<main>
			<time>2012-03-19</time>
			<article><p>** MISE À JOUR ** (22 mars 2012) : J’ai mis un exemple (simpliste, mais fonctionnel) de la structure suggérée dans ce billet sur GitHub, <a href="https://github.com/PuerkitoBio/express-boilerplate">express-boilerplate</a>.</p>

<hr/>

<p>La façon d’organiser son code, en divers répertoires et fichiers, est en bonne partie une question de préférence personnelle. Le cadre d’application Web (<em>Web framework</em>) <a href="http://expressjs.com/">Express</a> n’impose aucune structure particulière, laissant le développeur totalement libre d’arranger le tout selon son inspiration du moment. Cette liberté peut parfois donner le vertige et provoquer un effet pervers: le syndrome de la page blanche.</p>

<p>C’est probablement pourquoi <a href="http://stackoverflow.com/questions/9607947/how-should-i-structure-my-node-express-mongodb-app">la question</a> revient <a href="https://groups.google.com/forum/#!topic/express-js/9WrW3dxXqDs">aussi souvent</a>. Bien qu’il n’y ait pas de <em>bonne structure</em> canonique, les bonnes pratiques reconnues et un peu d’expérimentation permettent d’avancer une proposition réfléchie.</p>

<h3>Par défaut: la structure Express</h3>

<p>Quand je dis que Express n’impose aucune structure, c’est vrai, mais ce n’est pas toute la vérité. Il <em>suggère</em> une structure, lorsqu’on utilise l’outil de ligne de commande pour créer un cadre de départ (ex.: <code>express struct_express</code>). Ça donne ceci (avec la version 2.5.5):</p>

<pre><code>struct_express
    public
        images
        javascripts
        stylesheets
    routes
    views
    app.js
</code></pre>

<p>On comprend aisément que <em>public</em> contient les contenus non sécurisés, utilisés par les pages html produites par l’application et pris en charge par <a href="http://www.senchalabs.org/connect/">Connect</a> (le cadre applicatif plus générique sur lequel est construit Express) via l’intergiciel (<em>middleware</em>) de fichiers statiques.</p>

<p>Le répertoire <em>routes</em> porte à confusion, car à l’analyse du code qu’il contient (dans <em>index.js</em>), on n’y retrouve non pas la définition des URLs et des verbes HTTP supportés par l’application (la <em>route</em>), mais seulement l’implémentation, la logique applicative rattachée à cette route:</p>

<pre><code>:::javascript
// Fichier /routes/index.js
exports.index = function(req, res){
    res.render(&#39;index&#39;, { title: &#39;Express&#39; })
};
</code></pre>

<p>La définition de la route comme telle, elle, se retrouve à la racine de l’application, dans le fichier maître <em>app.js</em>:</p>

<pre><code>:::javascript
// Fichier /app.js
var express = require(&#39;express&#39;)
  , routes = require(&#39;./routes&#39;)

// ...
// Routes
app.get(&#39;/&#39;, routes.index);
</code></pre>

<p>C’est probablement acceptable pour de petits projets ou des tests rapides, mais pour une application d’une certaine taille, une meilleure organisation du code est nécessaire. Personnellement, je veux:</p>

<ul>
<li>un fichier de tête le plus bête possible, qu’il ne connaisse que les dépendances à obtenir et la façon de les assembler, sans aucune intelligence au niveau de l’implémentation.</li>
<li>des fichiers (des modules, si on adhère au vocabulaire du <a href="http://www.commonjs.org/">CommonJS</a> suivi par node) courts, simples à comprendre, respectant le <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">principe de responsabilité unique</a> (<em>single responsibility principle</em>).</li>
<li>du découplage par injection de dépendance, du code facilement testable.</li>
<li>une structure respectant les bonnes pratiques, les conventions généralement acceptées par la communauté.</li>
</ul>

<h3>Une saine organisation</h3>

<p>Voici l’organisation que je propose, qui permet de répondre à ces exigences:</p>

<pre><code>struct_express_amelioree
    lib
        config
        db
        handler
        router
        server
    public
        css
        img
        js
    test
    views
    app.js
</code></pre>

<p>Quelques constats rapides:</p>

<ul>
<li>Le code “serveur” se retrouve sous <em>/lib</em>, et les tests automatisés sous <em>/test</em>, une convention suivie par la plupart des ténors de la communauté.</li>
<li>Sous <em>/public</em>, on retrouve les trois mêmes répertoires de contenu statique, mais avec des noms plus courts, simple question de préférence et quelques octets de gagnés!</li>
<li>Sous <em>/views</em>, on retrouve les modèles de vues (<em>templates</em>) servant à produire les pages html. Personnellement j’utilise <a href="http://jade-lang.com/">jade</a>, mais Express supporte d’autres engins.</li>
<li><em>/lib</em> contient le coeur de l’application. Chaque sous-item a une responsabilité précise, et <a href="http://nodejs.org/api/modules.html#modules_folders_as_modules">grâce à la flexibilité offerte par node</a>, chaque sous-item peut prendre la forme d’un fichier unique ou d’un sous-répertoire et ainsi permettre une meilleure organisation (en multiples fichiers) de ce sous-item.</li>
</ul>

<p>Puisque c’est là l’essentiel du code serveur d’une application Web, voici en détail chacun des sous-items de <em>/lib</em>:</p>

<ul>
<li><strong>config</strong> contient la configuration du serveur Express, soit en général la mise en place des intergiciels utilisés (<em>middleware</em>), la configuration de l’engin de vues, la configuration de la gestion des erreurs selon l’environnement d’exécution, etc. Typiquement j’utilise un seul fichier, donc il prend la forme de <em>config.js</em>.</li>
<li><strong>db</strong> contient la couche d’acces aux données, de même que la définition des modèles utilisés par l’application. Certains préféreront peut-être appeler ce répertoire <em>models</em>. Personnellement j’utilise souvent <a href="http://www.mongodb.org/">MongoDB</a> et la librairie node <a href="http://mongoosejs.com/">mongoose</a>, donc je structure <em>db</em> sous la forme d’un répertoire avec <em>index.js</em> pour gérer la connexion à la base de données, et un fichier distinct par modèle, chacun des modèles étant exposé via <em>index.js</em>.</li>
<li><strong>handler</strong> contient la logique applicative à appliquer lors de requêtes sur les routes supportées. Je découpe habituellement les implémentations en différents fichiers, par exemple un fichier distinct pour les <em>handlers</em> des routes REST de chaque modèle. Ces implémentations sont indépendantes des routes, la définition de celles-ci étant l’affaire du…</li>
<li><strong>router</strong>, qui contient la définition des routes supportées par l’application. Là aussi, je suis le même découpage que pour les <em>handlers</em>, donc un fichier contenant les routes REST d’un modèle, un fichier contenant les routes de l’interface utilisateur, etc.</li>
<li><strong>server</strong> contient la création du serveur HTTP comme tel, ce qui est généralement appelé l’“app” dans les exemples d’Express, mais qui est plus spécifiquement le serveur Web (l’application étant l’ensemble des modules et leurs dépendances!). C’est souvent un module très simple, qui peut se limiter à appeler <code>express.CreateServer()</code>, donc j’utilise un seul fichier, <em>server.js</em>.</li>
</ul>

<p>Ce qui laisse un fichier de tête <em>app.js</em> effectivement très simple et sans intelligence autre que l’assemblage des modules, l’injection des dépendances, et l’appel à <code>server.listen()</code> pour démarrer l’application Web. Ça donne une organisation saine, qui permet de respecter le patron <a href="http://fr.wikipedia.org/wiki/Mod%C3%A8le-Vue-Contr%C3%B4leur">MVC</a> où, grossièrement, le modèle est <em>/lib/db</em>, la vue est <em>/views</em> et le contrôleur est une combinaison de <em>/lib/router</em> et <em>/lib/handler</em>, le <em>router</em> jouant le rôle d’“agent messager”, et le <em>handler</em> contenant la logique comme telle. D’ailleurs j’utilise un découpage semblable pour organiser le code côté client (en développement, avant de les <em>minifier</em>), dans mes fichiers sous <em>/public/js</em> avec <a href="http://backbonejs.org/">backbone.js</a>, mais c’est une histoire pour un autre billet.</p>

<p>Est-ce que votre organisation du code ressemble à ça? Utilisez-vous quelque chose de radicalement différent? Faites-en part dans les commentaires!</p>
</article>
		</main>
		<footer>
			<div class="container">
				<div class="left">
					<a href="https://github.com/PuerkitoBio" title="@PuerkitoBio on GitHub">
						<span class="icon-github-circled"></span>
					</a>
				</div>
				<div class="right">
					<a href="https://twitter.com/PuerkitoBio" title="@PuerkitoBio on Twitter">
						<span class="icon-twitter"></span>
					</a>
				</div>
				<div class="middle">
					<h3>Recent posts</h3>
					<ul>
						<li>
							<a href="010-demenagement">Ce blogue a déménagé sur GitHub</a>
						</li>
						<li>
							<a href="009-je-men-vais">Je suis venu te dire que je m&#39;en vais</a>
						</li>
						<li>
							<a href="008-backbone-computed-properties">Propriétés calculées avec Backbone</a>
						</li>
						<li>
							<a href="007-implement-js">implement.js: typage fort et Javascript</a>
						</li>
						<li>
							<a href="006-dependency-injection">Expérimentations sur l&#39;injection de dépendance avec node.js</a>
						</li>
					</ul>
				</div>
				<div class="clearfix"></div>
			</div>
			<div class="container copyright">
				<small>
					built with 
					<a href="https://github.com/PuerkitoBio/trofaf">trofaf</a>
					.
				</small>
				<br />
				<small>© 2013 Martin Angers</small>
			</div>
		</footer>
	</body>
</html>
